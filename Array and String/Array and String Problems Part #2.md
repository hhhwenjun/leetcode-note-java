# Array and String Problems Part #2

## Permutation in String(Medium #567)

**Question**: Given two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

**Example 1:**

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

**Constraints:**

-   `1 <= s1.length, s2.length <= 104`
-   `s1` and `s2` consist of lowercase English letters.

### My Solution

*   Use a hashset to store the permutations, and use a slicing window to find if substring is contained by the hash set.
*   For the permutations, we can use backtracking to find all the permutations.
*   The method works, but it run over time limit since when the word is long, the runtime would be extremely slow.
*   Noted that actually we only need to return true or false, not the exact permutation, so we actually don't need to do backtracking.

```java
public boolean checkInclusion(String s1, String s2) {
    // s1 is the word, s2 is the string to find permutation word
    // build a arraylist to store the string since string is immutable
    if (s1.length() > s2.length()) return false;
    String[] wordString = s1.split("");
    int wordLength = s1.length();
    List<String> word = new ArrayList<>(Arrays.asList(wordString));
    Set<String> comb = new HashSet<>();
    permutation(0, comb, word);
    return check(comb, s2, wordLength);
}

public boolean check(Set<String> combination, String range, int wordLength){
    int rangeLength = range.length();
    String target;
    for (int i = 0; i < rangeLength - wordLength; i++){
        target = range.substring(i, i + wordLength);
        if (combination.contains(target)){
            return true;
        }
    }
    // the very end last possible permutation
    if (combination.contains(range.substring(rangeLength - wordLength))){
        return true;
    }
    return false;
}

public void permutation(int loc, Set<String> combination, List<String> word){
    if (loc == word.size()){
        StringBuilder wordString = new StringBuilder();
        for(String letter : word){
            wordString.append(letter);
        }
        combination.add(wordString.toString());
    }
    // loop through the word and store any combination to the set
    for (int begin = loc; begin < word.size(); begin++){
        Collections.swap(word, begin, loc);
        permutation(loc + 1, combination, word);
        Collections.swap(word, begin, loc);
    }
}
```

### Standard Solution

#### Solution #1 Slicing Window

```java
public boolean checkInclusion(String s1, String s2){
   if (s1.length() > s2.length()) return false;
   // we only need to check if they have same number letters in the string
   int[] s1map = new int[26];
   int[] s2map = new int[26];
   for (int i = 0; i < s1.length(); i++){
       s1map[s1.charAt(i) - 'a']++;
       s2map[s2.charAt(i) - 'a']++;
   }
   // each time modify the s2map to the current slicing window
   for (int i = 0; i < s2.length() - s1.length(); i++){
       if (matches(s1map, s2map)) return true;// if current slicing window met
       // move to the next window, step is 1
       s2map[s2.charAt(i + s1.length()) - 'a']++;
       s2map[s2.charAt(i) - 'a']--;
   }
   return matches(s1map, s2map);
}

public boolean matches(int[] s1map, int[] s2map){
    for (int i = 0; i < 26; i++){
        if (s1map[i] != s2map[i]){
            return false;
        }
    }
    return true;
}
```

*   Time complexity: $O(l_1+26*(l_2-l_1))$, where $l_1$ is the length of string $l_1$ and $l_2$ is the length of string $l_2$.
*   Space complexity: $O(1)$. Constant space is used.

## Find the Difference(Easy #389)

**Question**: You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`.

**Example 1:**

```
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```

**Example 2:**

```
Input: s = "", t = "y"
Output: "y"
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `t.length == s.length + 1`
-   `s` and `t` consist of lowercase English letters.

### My Solution

```java
public char findTheDifference(String s, String t) {
    int[] stringMap1 = new int[26];
    int[] stringMap2 = new int[26];
    char[] sArry = s.toCharArray();
    char[] tArry = t.toCharArray();
    int findLoc;
    // record the char in string and map to the int array
    for (int i = 0; i < sArry.length; i++){
        findLoc = sArry[i] - 'a';
        stringMap1[findLoc]++;
    }
    for (int i = 0; i < tArry.length; i++){
        findLoc = tArry[i] - 'a';
        stringMap2[findLoc]++;
    }
    char target = 'a';
    // compare two array to see which location is different and output
    for (int i = 0; i < stringMap1.length; i++){
        if (stringMap1[i] != stringMap2[i]){
            target = (char)('a' + i);
            break;
        }
    }
    return target;
}
```

### Standard Solution

#### Solution #1 Using HashMap

*   Use hashmap to store the string letter and its occurrence.
*   Then loop through another string and subtract the occurrence in hashmap until reaches 0.
*   Any new letter that is beyond the hashmap occurrence is the target.

```java
public char findTheDifference(String s, String t){
    char extraChar = '\0'; // just random initialization
    
    // prepare a counter for string s.
    // this hashmap holds the characters as keys and respective frequency as value
    HashMap<Character, Integer> counterS = new HashMap<>();
    for (int i = 0; i < s.length(); i++){
        char ch = s.charAt(i);
        counterS.put(ch, counterS.getOrDefault(ch, 0) + 1);
    }
    // Iterate through string t and find the character which is not in s.
    for (int i = 0; i < t.length(); i++){
        char ch = t.charAt(i);
        int countOfChar = counterS.getOrDefault(ch, 0);
        if (countOfChar == 0){
            extraChar = ch;
            break;
        } else {
            // once a match is found we reduce frequency left.
            // this eliminates the possibility of a false match later.
            counterS.put(ch, countOfChar - 1);
        }
    }
    return extraChar;
}
```

*   Time Complexity: $O(N)$, where N is length of the strings. Since, we iterate through both the strings once.
*   Space Complexity: $O(1)$. The problem states string `s` and string `t` have lowercase letters. Thus, the total number of unique characters and eventually buckets in the hash map possible are just 26.

## Zigzag Conversion (Medium #6)

**Qestion**: The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R
```

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:

```
string convert(string s, int numRows);
```

**Example 1:**

```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

**Example 2:**

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**Example 3:**

```
Input: s = "A", numRows = 1
Output: "A"
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
-   `1 <= numRows <= 1000`

### My Solution

```java
 public String convert(String s, int numRows) {
    // use list to store the value into List<List<String>>, depends on (n - 4) % numRows
    if (s == null || s.length() < 2 || numRows < 2) return s;
    List<List<String>> stringList = new ArrayList<>();

    // create lists based on the numRows
    for (int i = 0; i < numRows; i++){
        stringList.add(new ArrayList<>());
    }
    int round = (numRows - 1)*2; // from 0 level round back to 0 level
    int maxLevel = numRows - 1;
    int divideNum = 0;
    // loop through the string s and store the string letter in different lists
    for (int i = 0; i < s.length(); i++){
        char letter = s.charAt(i);
        divideNum = i % round;
        // go backward
        if (divideNum > maxLevel){
            stringList.get(round - divideNum).add(Character.toString(letter));
        }
        else {
            stringList.get(divideNum).add(Character.toString(letter));
        }
    }
    // now we get all the string and concat them together
    String res = "";
    for (int i = 0; i < numRows; i++){
        for (String item : stringList.get(i)){
            res += item;
        }
    }
    return res;
}
```

### Standard Solution

#### Solution #1 Sort by Row

*   Iterate through s*s* from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.
*   The current direction changes only when we moved up to the topmost row or move down to the bottommost row.
*   Use `curRow` to check the current row number and `goingDown` to keep track of the direction

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    List<StringBuilder> rows = new ArrayList<>();
    for (int i = 0; i < Math.min(numRows, s.length()); i++){
        rows.add(new Stringbuilder());
    }
    int curRow = 0;
    boolean goingDown = false;
    for (char c : s.toCharArray()){
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }
    StringBuilder ret = new StringBuilder();
    for (StringBuilder row : rows) ret.append(row);
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}$
*   Space Complexity: $O(n)$

#### Solution #2 Visit by Row

*   Similar to my solution but less space complexity
*   Visit all rows 1 by 1
*   Use the cycle length and condition to record string row by row

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    
    StringBuilder ret = new StringBuilder();
    int n = s.length();
    int cycleLen = 2 * numRows - 2;
    for (int i = 0; i < numRows; i++){
        for (int j = 0; j + i < n; j += cycleLen){
            ret.append(s.charAt(j + i));
            if (i != 0 && i != numRows - 1 && j + cycleLen - i < n){
                ret.append(s.charAt(j + cycleLen - i));
            }
        }
    }
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}(s)$. Each index is visited once.
*   Space Complexity: $O(n)$. For the cpp implementation, $O(1)$ if return string is not considered extra space.

## Merge Sorted Array(Easy #88)

**Question**: You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

The final sorted array should not be returned by the function, but instead be *stored inside the array* `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

**Example 1:**

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
```

**Constraints:**

-   `nums1.length == m + n`
-   `nums2.length == n`
-   `0 <= m, n <= 200`
-   `1 <= m + n <= 200`
-   `-109 <= nums1[i], nums2[j] <= 109`

### My Solution

*   Since we have enough space in nums1, we can put nums2 to the nums1, and sort

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    for(int i = m, j = 0; i < nums1.length; i++, j++){
        nums1[i] = nums2[j];
    }
    Arrays.sort(nums1);
}
```

-   Time complexity: $\mathcal{O}((n + m)\log(n + m))$.

    The cost of sorting a list of length x*x* using a built-in sorting algorithm is $\mathcal{O}(x \log x)$. Because in this case, we're sorting a list of length $m + n$, we get a total time complexity of $\mathcal{O}((n + m) \log (n + m))$.

-   Space complexity: $\mathcal{O}(n)$, but it can vary.

    Most programming languages have a built-in sorting algorithm that uses $\mathcal{O}(n)$ space.

### Standard Solution

#### Solution #1 Three-Pointers

*   Because each array is already sorted, we can achieve an $\mathcal{O}(n + m)$ time complexity with the help of the *two-pointer technique*.
*   Copy the nums1 array, using two read pointers point the nums1 copy and num2. Compare their value.
*   Use a write pointer point to the nums1, to write the compared value.

```java
public void merge(int[] nums1, int m, int[] nums2, int n){
    // make a copy of the first m elements of nums1.
    int[] nums1Copy = new int[m];
    for (int i = 0; i < m; i++){
        nums1Copy[i] = nums1[i];
    }
    // read pointers for nums1Copy and nums2 respectively.
    int p1 = 0;
    int p2 = 0;
    
    // compare elements from nums1Copy and nums2 and write the smallest to nums1.
    for (int p = 0; p < m + n; p++){
        // we also need to ensure that p1 and p2 aren't over the boundaries
        if (p2 >= n || (p1 < m && nums1Copy[p1] < nums2[p2])){
            nums1[p] = nums1Copy[p1++];
        } else {
            nums1[p] = nums2[p2++];
        }
    }
}
```

-   Time complexity: $\mathcal{O}(n + m)$.

    We are performing $n + 2 \cdot m$ reads and $n + 2 \cdot m$ writes. Because constants are ignored in Big O notation, this gives us a time complexity of $\mathcal{O}(n + m)$.

-   Space complexity: $\mathcal{O}(m)$.

    We are allocating an additional array of length m.

## Is Subsequence(Easy #392)

**Question**: Given two strings `s` and `t`, return `true` *if* `s` *is a **subsequence** of* `t`*, or* `false` *otherwise*.

A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `"ace"` is a subsequence of `"abcde"` while `"aec"` is not).

**Example 1:**

```
Input: s = "abc", t = "ahbgdc"
Output: true
```

**Example 2:**

```
Input: s = "axc", t = "ahbgdc"
Output: false
```

**Constraints:**

-   `0 <= s.length <= 100`
-   `0 <= t.length <= 104`
-   `s` and `t` consist only of lowercase English letters.

### My Solution

```java
public boolean isSubsequence(String s, String t) {
    if (s.equals("")) return true;
    char[] schar = s.toCharArray();
    int idx = 0;
    for (int i = 0; i < t.length(); i++){
        if (t.charAt(i) == schar[idx]){
            idx++;
        }
        if (idx == schar.length){
            return true;
        }
    }
    return false;
}
```

*   Time complexity: $O(T)$
*   Space complexity: $O(1)$

### Standard Solution

#### Solution #1 Two Pointers

*   There are other solutions but way more complicated
*   Similar to my solution

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        Integer leftBound = s.length(), rightBound = t.length();
        Integer pLeft = 0, pRight = 0;
        while (pLeft < leftBound && pRight < rightBound) {
            // move both pointers or just the right pointer
            if (s.charAt(pLeft) == t.charAt(pRight)) {
                pLeft += 1;
            }
            pRight += 1;
        }
        return pLeft == leftBound;
    }
}
```

*   Complexity should be same as my solution

## Search Insert Position(Easy #35)

**Question**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

**Example 2:**

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Example 3:**

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 104`
-   `-104 <= nums[i] <= 104`
-   `nums` contains **distinct** values sorted in **ascending** order.
-   `-104 <= target <= 104`

### My Solution

*   The easiest one, but not meet the runtime requirement

```java
public int searchInsert(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++){
        if (nums[i] == target){
            return i;
        }
        if (nums[i] > target){
            return i;
        }
    }
    return nums.length;
}
```

### Standard Solution

#### Solution #1 Binary Search

*   Binary search can shorten the running time

```java
  public int searchInsert(int[] nums, int target) {
    int pivot, left = 0, right = nums.length - 1;
    while (left <= right) {
      pivot = left + (right - left) / 2;
      if (nums[pivot] == target) return pivot;
      if (target < nums[pivot]) right = pivot - 1;
      else left = pivot + 1;
    }
    return left;
  }
```

*   Time complexity : $\mathcal{O}(\log N)$.
*   Space complexity : $\mathcal{O}(1)$ since it's a constant space solution.

## Integer to Roman(Medium #12)

**Question**: Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

-   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
-   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
-   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**

```
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
```

**Example 2:**

```
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
```

**Example 3:**

```
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Constraints:**

-   `1 <= num <= 3999`

### Standard Solution

#### Solution #1 Greedy

*   `private static final` to present all the possibilities
*   Mapping the number to the map

```java
private static final int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};    
private static final String[] symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

public String intToRoman(int num) {
    StringBuilder sb = new StringBuilder();
    // Loop through each symbol, stopping if num becomes 0.
    for (int i = 0; i < values.length && num > 0; i++) {
        // Repeat while the current symbol still fits into num.
        while (values[i] <= num) {
            num -= values[i];
            sb.append(symbols[i]);
        }
    }
    return sb.toString();
}
```

-   Time complexity: $O(1)$.

    As there is a finite set of roman numerals, there is a hard upper limit on how many times the loop can iterate. This upper limit is `15` times, and it occurs for the number `3888`, which has a representation of `MMMDCCCLXXXVIII`. Therefore, we say the time complexity is constant, i.e. $O(1)$.

-   Space complexity: $O(1)$.

    The amount of memory used does not change with the size of the input integer and is therefore constant.

#### Solution #2 Hardcode Digits

*   Almost similar to the above solution
*   Put all possible digits in roman in `private static final` 

```java
private static final String[] thousands = {"", "M", "MM", "MMM"};
private static final String[] hundreds = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}; 
private static final String[] tens = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
private static final String[] ones = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

public String intToRoman(int num) { 
    return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];
}
```

*   Time and space complexity is same as above.