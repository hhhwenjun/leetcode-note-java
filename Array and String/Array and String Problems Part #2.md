# Array and String Problems Part #2

## Permutation in String(Medium #567)

**Question**: Given two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

**Example 1:**

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

**Constraints:**

-   `1 <= s1.length, s2.length <= 104`
-   `s1` and `s2` consist of lowercase English letters.

### My Solution

*   Use a hashset to store the permutations, and use a slicing window to find if substring is contained by the hash set.
*   For the permutations, we can use backtracking to find all the permutations.
*   The method works, but it run over time limit since when the word is long, the runtime would be extremely slow.
*   Noted that actually we only need to return true or false, not the exact permutation, so we actually don't need to do backtracking.

```java
public boolean checkInclusion(String s1, String s2) {
    // s1 is the word, s2 is the string to find permutation word
    // build a arraylist to store the string since string is immutable
    if (s1.length() > s2.length()) return false;
    String[] wordString = s1.split("");
    int wordLength = s1.length();
    List<String> word = new ArrayList<>(Arrays.asList(wordString));
    Set<String> comb = new HashSet<>();
    permutation(0, comb, word);
    return check(comb, s2, wordLength);
}

public boolean check(Set<String> combination, String range, int wordLength){
    int rangeLength = range.length();
    String target;
    for (int i = 0; i < rangeLength - wordLength; i++){
        target = range.substring(i, i + wordLength);
        if (combination.contains(target)){
            return true;
        }
    }
    // the very end last possible permutation
    if (combination.contains(range.substring(rangeLength - wordLength))){
        return true;
    }
    return false;
}

public void permutation(int loc, Set<String> combination, List<String> word){
    if (loc == word.size()){
        StringBuilder wordString = new StringBuilder();
        for(String letter : word){
            wordString.append(letter);
        }
        combination.add(wordString.toString());
    }
    // loop through the word and store any combination to the set
    for (int begin = loc; begin < word.size(); begin++){
        Collections.swap(word, begin, loc);
        permutation(loc + 1, combination, word);
        Collections.swap(word, begin, loc);
    }
}
```

### Standard Solution

#### Solution #1 Slicing Window

```java
public boolean checkInclusion(String s1, String s2){
   if (s1.length() > s2.length()) return false;
   // we only need to check if they have same number letters in the string
   int[] s1map = new int[26];
   int[] s2map = new int[26];
   for (int i = 0; i < s1.length(); i++){
       s1map[s1.charAt(i) - 'a']++;
       s2map[s2.charAt(i) - 'a']++;
   }
   // each time modify the s2map to the current slicing window
   for (int i = 0; i < s2.length() - s1.length(); i++){
       if (matches(s1map, s2map)) return true;// if current slicing window met
       // move to the next window, step is 1
       s2map[s2.charAt(i + s1.length()) - 'a']++;
       s2map[s2.charAt(i) - 'a']--;
   }
   return matches(s1map, s2map);
}

public boolean matches(int[] s1map, int[] s2map){
    for (int i = 0; i < 26; i++){
        if (s1map[i] != s2map[i]){
            return false;
        }
    }
    return true;
}
```

*   Time complexity: $O(l_1+26*(l_2-l_1))$, where $l_1$ is the length of string $l_1$ and $l_2$ is the length of string $l_2$.
*   Space complexity: $O(1)$. Constant space is used.

## Find the Difference(Easy #389)

**Question**: You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`.

**Example 1:**

```
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```

**Example 2:**

```
Input: s = "", t = "y"
Output: "y"
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `t.length == s.length + 1`
-   `s` and `t` consist of lowercase English letters.

### My Solution

```java
public char findTheDifference(String s, String t) {
    int[] stringMap1 = new int[26];
    int[] stringMap2 = new int[26];
    char[] sArry = s.toCharArray();
    char[] tArry = t.toCharArray();
    int findLoc;
    // record the char in string and map to the int array
    for (int i = 0; i < sArry.length; i++){
        findLoc = sArry[i] - 'a';
        stringMap1[findLoc]++;
    }
    for (int i = 0; i < tArry.length; i++){
        findLoc = tArry[i] - 'a';
        stringMap2[findLoc]++;
    }
    char target = 'a';
    // compare two array to see which location is different and output
    for (int i = 0; i < stringMap1.length; i++){
        if (stringMap1[i] != stringMap2[i]){
            target = (char)('a' + i);
            break;
        }
    }
    return target;
}
```

### Standard Solution

#### Solution #1 Using HashMap

*   Use hashmap to store the string letter and its occurrence.
*   Then loop through another string and subtract the occurrence in hashmap until reaches 0.
*   Any new letter that is beyond the hashmap occurrence is the target.

```java
public char findTheDifference(String s, String t){
    char extraChar = '\0'; // just random initialization
    
    // prepare a counter for string s.
    // this hashmap holds the characters as keys and respective frequency as value
    HashMap<Character, Integer> counterS = new HashMap<>();
    for (int i = 0; i < s.length(); i++){
        char ch = s.charAt(i);
        counterS.put(ch, counterS.getOrDefault(ch, 0) + 1);
    }
    // Iterate through string t and find the character which is not in s.
    for (int i = 0; i < t.length(); i++){
        char ch = t.charAt(i);
        int countOfChar = counterS.getOrDefault(ch, 0);
        if (countOfChar == 0){
            extraChar = ch;
            break;
        } else {
            // once a match is found we reduce frequency left.
            // this eliminates the possibility of a false match later.
            counterS.put(ch, countOfChar - 1);
        }
    }
    return extraChar;
}
```

*   Time Complexity: $O(N)$, where N is length of the strings. Since, we iterate through both the strings once.
*   Space Complexity: $O(1)$. The problem states string `s` and string `t` have lowercase letters. Thus, the total number of unique characters and eventually buckets in the hash map possible are just 26.

## Zigzag Conversion (Medium #6)

**Qestion**: The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R
```

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:

```
string convert(string s, int numRows);
```

**Example 1:**

```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

**Example 2:**

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**Example 3:**

```
Input: s = "A", numRows = 1
Output: "A"
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
-   `1 <= numRows <= 1000`

### My Solution

```java
 public String convert(String s, int numRows) {
    // use list to store the value into List<List<String>>, depends on (n - 4) % numRows
    if (s == null || s.length() < 2 || numRows < 2) return s;
    List<List<String>> stringList = new ArrayList<>();

    // create lists based on the numRows
    for (int i = 0; i < numRows; i++){
        stringList.add(new ArrayList<>());
    }
    int round = (numRows - 1)*2; // from 0 level round back to 0 level
    int maxLevel = numRows - 1;
    int divideNum = 0;
    // loop through the string s and store the string letter in different lists
    for (int i = 0; i < s.length(); i++){
        char letter = s.charAt(i);
        divideNum = i % round;
        // go backward
        if (divideNum > maxLevel){
            stringList.get(round - divideNum).add(Character.toString(letter));
        }
        else {
            stringList.get(divideNum).add(Character.toString(letter));
        }
    }
    // now we get all the string and concat them together
    String res = "";
    for (int i = 0; i < numRows; i++){
        for (String item : stringList.get(i)){
            res += item;
        }
    }
    return res;
}
```

### Standard Solution

#### Solution #1 Sort by Row

*   Iterate through s*s* from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.
*   The current direction changes only when we moved up to the topmost row or move down to the bottommost row.
*   Use `curRow` to check the current row number and `goingDown` to keep track of the direction

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    List<StringBuilder> rows = new ArrayList<>();
    for (int i = 0; i < Math.min(numRows, s.length()); i++){
        rows.add(new Stringbuilder());
    }
    int curRow = 0;
    boolean goingDown = false;
    for (char c : s.toCharArray()){
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }
    StringBuilder ret = new StringBuilder();
    for (StringBuilder row : rows) ret.append(row);
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}$
*   Space Complexity: $O(n)$

#### Solution #2 Visit by Row

*   Similar to my solution but less space complexity
*   Visit all rows 1 by 1
*   Use the cycle length and condition to record string row by row

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    
    StringBuilder ret = new StringBuilder();
    int n = s.length();
    int cycleLen = 2 * numRows - 2;
    for (int i = 0; i < numRows; i++){
        for (int j = 0; j + i < n; j += cycleLen){
            ret.append(s.charAt(j + i));
            if (i != 0 && i != numRows - 1 && j + cycleLen - i < n){
                ret.append(s.charAt(j + cycleLen - i));
            }
        }
    }
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}(s)$. Each index is visited once.
*   Space Complexity: $O(n)$. For the cpp implementation, $O(1)$ if return string is not considered extra space.