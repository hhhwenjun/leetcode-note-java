# Array and String Problems Part #2

## Permutation in String(Medium #567)

**Question**: Given two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

**Example 1:**

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

**Constraints:**

-   `1 <= s1.length, s2.length <= 104`
-   `s1` and `s2` consist of lowercase English letters.

### My Solution

*   Use a hashset to store the permutations, and use a slicing window to find if substring is contained by the hash set.
*   For the permutations, we can use backtracking to find all the permutations.
*   The method works, but it run over time limit since when the word is long, the runtime would be extremely slow.
*   Noted that actually we only need to return true or false, not the exact permutation, so we actually don't need to do backtracking.

```java
public boolean checkInclusion(String s1, String s2) {
    // s1 is the word, s2 is the string to find permutation word
    // build a arraylist to store the string since string is immutable
    if (s1.length() > s2.length()) return false;
    String[] wordString = s1.split("");
    int wordLength = s1.length();
    List<String> word = new ArrayList<>(Arrays.asList(wordString));
    Set<String> comb = new HashSet<>();
    permutation(0, comb, word);
    return check(comb, s2, wordLength);
}

public boolean check(Set<String> combination, String range, int wordLength){
    int rangeLength = range.length();
    String target;
    for (int i = 0; i < rangeLength - wordLength; i++){
        target = range.substring(i, i + wordLength);
        if (combination.contains(target)){
            return true;
        }
    }
    // the very end last possible permutation
    if (combination.contains(range.substring(rangeLength - wordLength))){
        return true;
    }
    return false;
}

public void permutation(int loc, Set<String> combination, List<String> word){
    if (loc == word.size()){
        StringBuilder wordString = new StringBuilder();
        for(String letter : word){
            wordString.append(letter);
        }
        combination.add(wordString.toString());
    }
    // loop through the word and store any combination to the set
    for (int begin = loc; begin < word.size(); begin++){
        Collections.swap(word, begin, loc);
        permutation(loc + 1, combination, word);
        Collections.swap(word, begin, loc);
    }
}
```

### Standard Solution

#### Solution #1 Slicing Window

```java
public boolean checkInclusion(String s1, String s2){
   if (s1.length() > s2.length()) return false;
   // we only need to check if they have same number letters in the string
   int[] s1map = new int[26];
   int[] s2map = new int[26];
   for (int i = 0; i < s1.length(); i++){
       s1map[s1.charAt(i) - 'a']++;
       s2map[s2.charAt(i) - 'a']++;
   }
   // each time modify the s2map to the current slicing window
   for (int i = 0; i < s2.length() - s1.length(); i++){
       if (matches(s1map, s2map)) return true;// if current slicing window met
       // move to the next window, step is 1
       s2map[s2.charAt(i + s1.length()) - 'a']++;
       s2map[s2.charAt(i) - 'a']--;
   }
   return matches(s1map, s2map);
}

public boolean matches(int[] s1map, int[] s2map){
    for (int i = 0; i < 26; i++){
        if (s1map[i] != s2map[i]){
            return false;
        }
    }
    return true;
}
```

*   Time complexity: $O(l_1+26*(l_2-l_1))$, where $l_1$ is the length of string $l_1$ and $l_2$ is the length of string $l_2$.
*   Space complexity: $O(1)$. Constant space is used.

## Find the Difference(Easy #389)

**Question**: You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`.

**Example 1:**

```
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```

**Example 2:**

```
Input: s = "", t = "y"
Output: "y"
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `t.length == s.length + 1`
-   `s` and `t` consist of lowercase English letters.

### My Solution

```java
public char findTheDifference(String s, String t) {
    int[] stringMap1 = new int[26];
    int[] stringMap2 = new int[26];
    char[] sArry = s.toCharArray();
    char[] tArry = t.toCharArray();
    int findLoc;
    // record the char in string and map to the int array
    for (int i = 0; i < sArry.length; i++){
        findLoc = sArry[i] - 'a';
        stringMap1[findLoc]++;
    }
    for (int i = 0; i < tArry.length; i++){
        findLoc = tArry[i] - 'a';
        stringMap2[findLoc]++;
    }
    char target = 'a';
    // compare two array to see which location is different and output
    for (int i = 0; i < stringMap1.length; i++){
        if (stringMap1[i] != stringMap2[i]){
            target = (char)('a' + i);
            break;
        }
    }
    return target;
}
```

### Standard Solution

#### Solution #1 Using HashMap

*   Use hashmap to store the string letter and its occurrence.
*   Then loop through another string and subtract the occurrence in hashmap until reaches 0.
*   Any new letter that is beyond the hashmap occurrence is the target.

```java
public char findTheDifference(String s, String t){
    char extraChar = '\0'; // just random initialization
    
    // prepare a counter for string s.
    // this hashmap holds the characters as keys and respective frequency as value
    HashMap<Character, Integer> counterS = new HashMap<>();
    for (int i = 0; i < s.length(); i++){
        char ch = s.charAt(i);
        counterS.put(ch, counterS.getOrDefault(ch, 0) + 1);
    }
    // Iterate through string t and find the character which is not in s.
    for (int i = 0; i < t.length(); i++){
        char ch = t.charAt(i);
        int countOfChar = counterS.getOrDefault(ch, 0);
        if (countOfChar == 0){
            extraChar = ch;
            break;
        } else {
            // once a match is found we reduce frequency left.
            // this eliminates the possibility of a false match later.
            counterS.put(ch, countOfChar - 1);
        }
    }
    return extraChar;
}
```

*   Time Complexity: $O(N)$, where N is length of the strings. Since, we iterate through both the strings once.
*   Space Complexity: $O(1)$. The problem states string `s` and string `t` have lowercase letters. Thus, the total number of unique characters and eventually buckets in the hash map possible are just 26.

## Zigzag Conversion (Medium #6)

**Qestion**: The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R
```

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:

```
string convert(string s, int numRows);
```

**Example 1:**

```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

**Example 2:**

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**Example 3:**

```
Input: s = "A", numRows = 1
Output: "A"
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
-   `1 <= numRows <= 1000`

### My Solution

```java
 public String convert(String s, int numRows) {
    // use list to store the value into List<List<String>>, depends on (n - 4) % numRows
    if (s == null || s.length() < 2 || numRows < 2) return s;
    List<List<String>> stringList = new ArrayList<>();

    // create lists based on the numRows
    for (int i = 0; i < numRows; i++){
        stringList.add(new ArrayList<>());
    }
    int round = (numRows - 1)*2; // from 0 level round back to 0 level
    int maxLevel = numRows - 1;
    int divideNum = 0;
    // loop through the string s and store the string letter in different lists
    for (int i = 0; i < s.length(); i++){
        char letter = s.charAt(i);
        divideNum = i % round;
        // go backward
        if (divideNum > maxLevel){
            stringList.get(round - divideNum).add(Character.toString(letter));
        }
        else {
            stringList.get(divideNum).add(Character.toString(letter));
        }
    }
    // now we get all the string and concat them together
    String res = "";
    for (int i = 0; i < numRows; i++){
        for (String item : stringList.get(i)){
            res += item;
        }
    }
    return res;
}
```

### Standard Solution

#### Solution #1 Sort by Row

*   Iterate through s*s* from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.
*   The current direction changes only when we moved up to the topmost row or move down to the bottommost row.
*   Use `curRow` to check the current row number and `goingDown` to keep track of the direction

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    List<StringBuilder> rows = new ArrayList<>();
    for (int i = 0; i < Math.min(numRows, s.length()); i++){
        rows.add(new Stringbuilder());
    }
    int curRow = 0;
    boolean goingDown = false;
    for (char c : s.toCharArray()){
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }
    StringBuilder ret = new StringBuilder();
    for (StringBuilder row : rows) ret.append(row);
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}$
*   Space Complexity: $O(n)$

#### Solution #2 Visit by Row

*   Similar to my solution but less space complexity
*   Visit all rows 1 by 1
*   Use the cycle length and condition to record string row by row

```java
public String convert(String s, int numRows){
    if (numRows == 1) return s;
    
    StringBuilder ret = new StringBuilder();
    int n = s.length();
    int cycleLen = 2 * numRows - 2;
    for (int i = 0; i < numRows; i++){
        for (int j = 0; j + i < n; j += cycleLen){
            ret.append(s.charAt(j + i));
            if (i != 0 && i != numRows - 1 && j + cycleLen - i < n){
                ret.append(s.charAt(j + cycleLen - i));
            }
        }
    }
    return ret.toString();
}
```

*   Time Complexity: $O(n)$, where $n == \text{len}(s)$. Each index is visited once.
*   Space Complexity: $O(n)$. For the cpp implementation, $O(1)$ if return string is not considered extra space.

## Merge Sorted Array(Easy #88)

**Question**: You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

The final sorted array should not be returned by the function, but instead be *stored inside the array* `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

**Example 1:**

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
```

**Constraints:**

-   `nums1.length == m + n`
-   `nums2.length == n`
-   `0 <= m, n <= 200`
-   `1 <= m + n <= 200`
-   `-109 <= nums1[i], nums2[j] <= 109`

### My Solution

*   Since we have enough space in nums1, we can put nums2 to the nums1, and sort

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    for(int i = m, j = 0; i < nums1.length; i++, j++){
        nums1[i] = nums2[j];
    }
    Arrays.sort(nums1);
}
```

-   Time complexity: $\mathcal{O}((n + m)\log(n + m))$.

    The cost of sorting a list of length x*x* using a built-in sorting algorithm is $\mathcal{O}(x \log x)$. Because in this case, we're sorting a list of length $m + n$, we get a total time complexity of $\mathcal{O}((n + m) \log (n + m))$.

-   Space complexity: $\mathcal{O}(n)$, but it can vary.

    Most programming languages have a built-in sorting algorithm that uses $\mathcal{O}(n)$ space.

### Standard Solution

#### Solution #1 Three-Pointers

*   Because each array is already sorted, we can achieve an $\mathcal{O}(n + m)$ time complexity with the help of the *two-pointer technique*.
*   Copy the nums1 array, using two read pointers point the nums1 copy and num2. Compare their value.
*   Use a write pointer point to the nums1, to write the compared value.

```java
public void merge(int[] nums1, int m, int[] nums2, int n){
    // make a copy of the first m elements of nums1.
    int[] nums1Copy = new int[m];
    for (int i = 0; i < m; i++){
        nums1Copy[i] = nums1[i];
    }
    // read pointers for nums1Copy and nums2 respectively.
    int p1 = 0;
    int p2 = 0;
    
    // compare elements from nums1Copy and nums2 and write the smallest to nums1.
    for (int p = 0; p < m + n; p++){
        // we also need to ensure that p1 and p2 aren't over the boundaries
        if (p2 >= n || (p1 < m && nums1Copy[p1] < nums2[p2])){
            nums1[p] = nums1Copy[p1++];
        } else {
            nums1[p] = nums2[p2++];
        }
    }
}
```

-   Time complexity: $\mathcal{O}(n + m)$.

    We are performing $n + 2 \cdot m$ reads and $n + 2 \cdot m$ writes. Because constants are ignored in Big O notation, this gives us a time complexity of $\mathcal{O}(n + m)$.

-   Space complexity: $\mathcal{O}(m)$.

    We are allocating an additional array of length m.

## Is Subsequence(Easy #392)

**Question**: Given two strings `s` and `t`, return `true` *if* `s` *is a **subsequence** of* `t`*, or* `false` *otherwise*.

A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `"ace"` is a subsequence of `"abcde"` while `"aec"` is not).

**Example 1:**

```
Input: s = "abc", t = "ahbgdc"
Output: true
```

**Example 2:**

```
Input: s = "axc", t = "ahbgdc"
Output: false
```

**Constraints:**

-   `0 <= s.length <= 100`
-   `0 <= t.length <= 104`
-   `s` and `t` consist only of lowercase English letters.

### My Solution

```java
public boolean isSubsequence(String s, String t) {
    if (s.equals("")) return true;
    char[] schar = s.toCharArray();
    int idx = 0;
    for (int i = 0; i < t.length(); i++){
        if (t.charAt(i) == schar[idx]){
            idx++;
        }
        if (idx == schar.length){
            return true;
        }
    }
    return false;
}
```

*   Time complexity: $O(T)$
*   Space complexity: $O(1)$

### Standard Solution

#### Solution #1 Two Pointers

*   There are other solutions but way more complicated
*   Similar to my solution

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        Integer leftBound = s.length(), rightBound = t.length();
        Integer pLeft = 0, pRight = 0;
        while (pLeft < leftBound && pRight < rightBound) {
            // move both pointers or just the right pointer
            if (s.charAt(pLeft) == t.charAt(pRight)) {
                pLeft += 1;
            }
            pRight += 1;
        }
        return pLeft == leftBound;
    }
}
```

*   Complexity should be same as my solution

## Search Insert Position(Easy #35)

**Question**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

**Example 2:**

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Example 3:**

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 104`
-   `-104 <= nums[i] <= 104`
-   `nums` contains **distinct** values sorted in **ascending** order.
-   `-104 <= target <= 104`

### My Solution

*   The easiest one, but not meet the runtime requirement

```java
public int searchInsert(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++){
        if (nums[i] == target){
            return i;
        }
        if (nums[i] > target){
            return i;
        }
    }
    return nums.length;
}
```

### Standard Solution

#### Solution #1 Binary Search

*   Binary search can shorten the running time

```java
  public int searchInsert(int[] nums, int target) {
    int pivot, left = 0, right = nums.length - 1;
    while (left <= right) {
      pivot = left + (right - left) / 2;
      if (nums[pivot] == target) return pivot;
      if (target < nums[pivot]) right = pivot - 1;
      else left = pivot + 1;
    }
    return left;
  }
```

*   Time complexity : $\mathcal{O}(\log N)$.
*   Space complexity : $\mathcal{O}(1)$ since it's a constant space solution.

## Integer to Roman(Medium #12)

**Question**: Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

-   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
-   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
-   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**

```
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
```

**Example 2:**

```
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
```

**Example 3:**

```
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Constraints:**

-   `1 <= num <= 3999`

### Standard Solution

#### Solution #1 Greedy

*   `private static final` to present all the possibilities
*   Mapping the number to the map

```java
private static final int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};    
private static final String[] symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

public String intToRoman(int num) {
    StringBuilder sb = new StringBuilder();
    // Loop through each symbol, stopping if num becomes 0.
    for (int i = 0; i < values.length && num > 0; i++) {
        // Repeat while the current symbol still fits into num.
        while (values[i] <= num) {
            num -= values[i];
            sb.append(symbols[i]);
        }
    }
    return sb.toString();
}
```

-   Time complexity: $O(1)$.

    As there is a finite set of roman numerals, there is a hard upper limit on how many times the loop can iterate. This upper limit is `15` times, and it occurs for the number `3888`, which has a representation of `MMMDCCCLXXXVIII`. Therefore, we say the time complexity is constant, i.e. $O(1)$.

-   Space complexity: $O(1)$.

    The amount of memory used does not change with the size of the input integer and is therefore constant.

#### Solution #2 Hardcode Digits

*   Almost similar to the above solution
*   Put all possible digits in roman in `private static final` 

```java
private static final String[] thousands = {"", "M", "MM", "MMM"};
private static final String[] hundreds = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}; 
private static final String[] tens = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
private static final String[] ones = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

public String intToRoman(int num) { 
    return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];
}
```

*   Time and space complexity is the same as above.

## Remove Duplicate Letters(Medium #316)

**Question**: Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.

**Example 1:**

```
Input: s = "bcabc"
Output: "abc"
```

**Example 2:**

```
Input: s = "cbacdcbc"
Output: "acdb"
```

**Constraints:**

-   `1 <= s.length <= 104`
-   `s` consists of lowercase English letters.

**Note:** This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/

### Standard Solution

#### Solution #1 Greedy Solving Letter by Letter

*   In each iteration, we determine the leftmost letter in our solution. This will be **the smallest character such that its suffix contains at least one copy of every character in the string**.
*   We determine the rest of our answer by recursively calling the function on the suffix we generate from the original string (the leftmost letter is removed).

```java
public String removeDuplicateLetters(String s) {
    int[] cnt = new int[26];
    int pos = 0;
    for (int i = 0; i < s.length(); i++){
        cnt[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < s.length(); i++){
        if (s.charAt(i) < s.charAt(pos)){
            pos = i;
        }
        if (--cnt[s.charAt(i) - 'a'] == 0) break;
    }
    return s.length() == 0 ? "" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll("" + s.charAt(pos), ""));
}
```

-   Time complexity: $O(N)$. Each recursive call will take $O(N)$. The number of recursive calls is bounded by a constant (26 letters in the alphabet), so we have $O(N) * C = O(N)$.
-   Space complexity: $O(N)$. Each time we slice the string we're creating a new one (strings are immutable). The number of slices is bound by a constant, so we have $O(N) * C = O(N)$.

## Minimum Domino Rotations For Equal Row(Medium #1007)

**Question**: In a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)

We may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.

Return the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.

If it cannot be done, return `-1`.

**Example 1:**

<img src="https://assets.leetcode.com/uploads/2021/05/14/domino.png" alt="img" style="zoom:50%;" />

```
Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.
```

**Example 2:**

```
Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.
```

**Constraints:**

-   `2 <= tops.length <= 2 * 104`
-   `bottoms.length == tops.length`
-   `1 <= tops[i], bottoms[i] <= 6`

### My Solution

```java
public int minDominoRotations(int[] tops, int[] bottoms) {
    int res = Integer.MAX_VALUE;
    int length = tops.length;
    int indicator = 0;
    int topNum = 0;
    int bottomNum = 0;

    for (int i = 1; i <= 6; i++){
        indicator = 0;
        topNum = 0;
        bottomNum = 0;

        for(int j = 0; j < length; j++){
            if(tops[j] == i || bottoms[j] == i){
                indicator++;
                if (tops[j] == i && bottoms[j] != i){
                    topNum++;
                }
                else if (tops[j] != i && bottoms[j] == i) {
                    bottomNum++;
                }
            }
        }
        if (indicator == length){
            res = Math.min(res, topNum);
            res = Math.min(res, bottomNum);
        }
    }
    return res == Integer.MAX_VALUE ? -1 : res;
}
```

### Standard Solution

#### Solution #1 Greedy

*   Algorithm: 
    *   Pick up the first element. It has two sides: `A[0]` and `B[0]`.
    *   Check if one could make all elements in `A` row or `B` row to be equal to `A[0]`. If yes, return the minimum number of rotations needed.
    *   Check if one could make all elements in `A` row or `B` row to be equal to `B[0]`. If yes, return the minimum number of rotations needed.
    *   Otherwise return `-1`.

```java
  public int check(int x, int[] A, int[] B, int n) {
    // how many rotations should be done
    // to have all elements in A equal to x
    // and to have all elements in B equal to x
    int rotations_a = 0, rotations_b = 0;
    for (int i = 0; i < n; i++) {
      // rotations coudn't be done
      if (A[i] != x && B[i] != x) return -1;
      // A[i] != x and B[i] == x
      else if (A[i] != x) rotations_a++;
      // A[i] == x and B[i] != x    
      else if (B[i] != x) rotations_b++;
    }
    // min number of rotations to have all
    // elements equal to x in A or B
    return Math.min(rotations_a, rotations_b);
  }

  public int minDominoRotations(int[] A, int[] B) {
    int n = A.length;
    int rotations = check(A[0], B, A, n);
    // If one could make all elements in A or B equal to A[0]
    if (rotations != -1 || A[0] == B[0]) return rotations;
    // If one could make all elements in A or B equal to B[0]
    else return check(B[0], B, A, n);
  }
```

-   Time complexity: $\mathcal{O}(N)$ since here one iterate over the arrays not more than two times.
-   Space complexity: $\mathcal{O}(1)$ since it's a constant space solution.

## Partition Labels(Medium #763)

**Question**: You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.

Return *a list of integers representing the size of these parts*.

**Example 1:**

```
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
```

**Example 2:**

```
Input: s = "eccbbbbdec"
Output: [10]
```

**Constraints:**

-   `1 <= s.length <= 500`
-   `s` consists of lowercase English letters.

### Standard Solution

#### Solution #1 Greedy

*   Each time record the last location of the letter
*   For each loop, record the maximum location of the substring, when reaching that location, add the length of the substring to the results.

```java
public List<Integer> partitionLabels(String S) {
    int[] last = new int[26];
    // each time record the last location
    for (int i = 0; i < S.length(); ++i)
        last[S.charAt(i) - 'a'] = i;

    int j = 0, anchor = 0;
    List<Integer> ans = new ArrayList();
    for (int i = 0; i < S.length(); ++i) {
        j = Math.max(j, last[S.charAt(i) - 'a']);
        if (i == j) {
            ans.add(i - anchor + 1);
            anchor = i + 1;
        }
    }
    return ans;
}
```

-   Time Complexity: $O(N)$, where $N$ is the length of S.
-   Space Complexity: $O(1)$ to keep the data structure `last` of not more than 26 characters.

## Smallest String With a Given Numeric Value(Medium #1663)

**Question**: The **numeric value** of a **lowercase character** is defined as its position `(1-indexed)` in the alphabet, so the numeric value of `a` is `1`, the numeric value of `b` is `2`, the numeric value of `c` is `3`, and so on.

The **numeric value** of a **string** consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string `"abe"` is equal to `1 + 2 + 5 = 8`.

You are given two integers `n` and `k`. Return *the **lexicographically smallest string** with **length** equal to `n` and **numeric value** equal to `k`.*

Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.

**Example 1:**

```
Input: n = 3, k = 27
Output: "aay"
Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.
```

**Example 2:**

```
Input: n = 5, k = 73
Output: "aaszz"
```

**Constraints:**

-   `1 <= n <= 105`
-   `n <= k <= 26 * n`

### Standard Solution

#### Solution #1 Build number from left to right

*   Check how many 'z' we have for n - 1 location. Put the rest value to the first location.
*   Otherwise, just put 1 to the first location. Put as many 'a' as possible.

```java
public String getSmallestString(int n, int k) {
    char[] result = new char[n];
    // length of the results
    for (int position = 0; position < n; position++){
        // last location of the result
        int positionsLeft = (n - position - 1);
        if (k > positionsLeft * 26){
            int add = k - (positionsLeft * 26);
            // rest of the exceeded limit move to beginning
            result[position] = (char)('a' + add - 1);
            k -= add;
        }
        else {
            result[position] = 'a';
            k--;
        }
    }
    return new String(result);
}
```

-   Time Complexity: $\mathcal{O}(n)$ as we iterate over n positions to build the resultant string.
-   Space Complexity: $\mathcal{O}(1)$, as we use constant extra space to store `add` and `position` variables.

#### Solution #2 Build number from right

*   Put 'a' to all locations, then try to put 'z' to take place of 'a' from the last location.

```java
public String getSmallestString(int n, int k) {
    char[] result = new char[n];
    Arrays.fill(result, 'a');
    k -= n;
    for (int position = n - 1; position >= 0 && k > 0; position--) {
        int add = Math.min(k, 25);
        result[position] = (char) (result[position] + add);
        k -= add;
    }
    return new String(result);
}
```

*   Complexity is the same.

#### Solution #3 Build number from the right - optimized solution

*   Put 'z' from the end location to the front until less than 'z'. Put as many values at the end as possible.

```java
public String getSamllestString(int n, int k){
    char[] result = new char[n];
    for (int position = n - 1; position >= 0; position--){
        int add = Math.min(k - position, 26);
        result[position] = (char)(add + 'a' - 1);
        k -= add;
    }
    return new String(result);
}
```

*   Complexity is the same.

## Binary Search(Easy #704)

**Question**: Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
```

**Example 2:**

```
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
```

**Constraints:**

-   `1 <= nums.length <= 104`
-   `-104 < nums[i], target < 104`
-   All the integers in `nums` are **unique**.
-   `nums` is sorted in ascending order.

### My Solution

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1, pivot = 0;
    while(left <= right){
        pivot = left + (right - left)/2;
        if (nums[pivot] == target){
            return pivot;
        }
        else if (nums[pivot] > target){
            right = pivot - 1;
        }
        else {
            left = pivot + 1;
        }
    }
    return -1;
}
```

### Standard Solution

#### Solution #1 Binary Search

*   Always remember to calculate pivot as `low + (high - low) / 2` wherever low is
*   Two pointers

```java
class Solution {
  public int search(int[] nums, int target) {
    int pivot, left = 0, right = nums.length - 1;
    while (left <= right) {
      pivot = left + (right - left) / 2;
      if (nums[pivot] == target) return pivot;
      if (target < nums[pivot]) right = pivot - 1;
      else left = pivot + 1;
    }
    return -1;
  }
}
```

*   Time complexity: $O(\log N)$
*   Space complexity: $O(1)$

## Rotate Image (Medium #48)

**Question**: You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

<img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img" style="zoom:50%;" />

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

<img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img" style="zoom:50%;" />

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `-1000 <= matrix[i][j] <= 1000`

### My Solution

*   Use a new matrix to record the content
*   But in a rotated way

```java
public void rotate(int[][] matrix) {
    // n * n matrix
    int length = matrix.length;
    int[][] res = new int[length][length];
    for (int i = 0; i < length; i++){
        for (int j = 0; j < length; j++){
            // row to column in new matrix
            res[i][j] = matrix[i][j];
        }
    }
    for (int i = 0; i < length; i++){
        for (int j = 0; j < length; j++){
            // row to column in new matrix
            matrix[j][length - 1 - i] = res[i][j];
        }
    }
}
```

### Standard Solution

#### Solution #1 Rotate

*   Similar to my solution
*   But using swap to save more memory

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < (n + 1) / 2; i++) {
        for (int j = 0; j < n / 2; j++) {
            int temp = matrix[n - 1 - j][i];
            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
            matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
            matrix[j][n - 1 - i] = matrix[i][j];
            matrix[i][j] = temp;
        }
    }
}
```

-   Time complexity: $\mathcal{O}(M)$, as each cell is getting read once and written once.
-   Space complexity: $\mathcal{O}(1)$ because we do not use any other additional data structures.

#### Solution #2 Transpose then Reversed

```java
public void rotate(int[][] matrix) {
    transpose(matrix);
    reflect(matrix);
}

public void transpose(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int tmp = matrix[j][i];
            matrix[j][i] = matrix[i][j];
            matrix[i][j] = tmp;
        }
    }
}

public void reflect(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[i][n - j - 1];
            matrix[i][n - j - 1] = tmp;
        }
    }
}
```

-   Time complexity: $\mathcal{O}(M)$. We perform two steps; transposing the matrix, and then reversing each row. Transposing the matrix has a cost of $\mathcal{O}(M)$ because we're moving the value of each cell once. Reversing each row also has a cost of $\mathcal{O}(M)$, because again we're moving the value of each cell once.
-   Space complexity: $\mathcal{O}(1)$ because we do not use any other additional data structures.

## Jump Game II (Medium #45)

**Question**: Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

### Standard Solution

#### Solution #1 Greedy

*   Each time we find the farthest point of the current point, compare the farthest
*   When reaching the end of the farthest jump, add 1 to the jumps.

```java
public int jump(int[] nums) {
    int jumps = 0, currentJumpEnd = 0, farthest = 0;
    for (int i = 0; i < nums.length - 1; i++){
        farthest = Math.max(farthest, i + nums[i]);
        if (i == currentJumpEnd){
            jumps++;
            currentJumpEnd = farthest;
        }
    }
    return jumps;
}
```

-   Time Complexity: $O(N)$ because there are N elements in the array and we visit each element in the array only once.
-   Space Complexity: $O(1)$ because we don't use any additional data structures.

## Valid Palindrome (Easy #125)

**Question**: A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` *if it is a **palindrome**, or* `false` *otherwise*.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

-   `1 <= s.length <= 2 * 105`
-   `s` consists only of printable ASCII characters.

### My Solution

*   Use a string builder to take the characters in the array, then compare the reversed one

```java
public boolean isPalindrome(String s) {
    s.trim();
    StringBuilder sb = new StringBuilder();
    char[] sArray = s.toCharArray();
    for(char ch : sArray){
        if(Character.isLetterOrDigit(ch)){
            sb.append(Character.toLowerCase(ch));
        }
    }
    return sb.toString().equals(sb.reverse().toString());
}
```

### Standard Solution

#### Solution #1 Compare with Reverse

*   Same as my solution

*   Time complexity: $O(n)$, in length n of the string.

    We need to iterate thrice through the string:

    1.  When we filter out non-alphanumeric characters, and convert the remaining characters to lower-case.
    2.  When we reverse the string.
    3.  When we compare the original and the reversed strings.

    Each iteration runs linear in time (since each character operation completes in constant time). Thus, the effective run-time complexity is linear.

*   Space complexity: $O(n$), in length n of the string. We need $O(n)$ additional space to store the filtered string and the reversed string.

#### Solution #2 Two Pointers

*   Each time compare two character 
*   If it is not a character, jump over it

```java
public boolean isPalindrome(String s){
    for (int i = 0, j = s.length() - 1; i < j; i++, j--){
        while(i < j && !Character.isLetterOrDigit(s.charAt(i))){
            i++;
        }
        while(i < j && !Character.isLetterOrDigit(s.charAt(j))){
            j--;
        }
        if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))){
            return false;
        }
    }
    return true;
}
```

-   Time complexity: $O(n)$, in length n of the string. We traverse over each character at-most-once, until the two pointers meet in the middle, or when we break and return early.
-   Space complexity: $O(1)$. No extra space is required, at all.

## Check if Number Has Equal Digit Count and Digit Value (Easy #2283)

**Question**: You are given a **0-indexed** string `num` of length `n` consisting of digits.

Return `true` *if for **every** index* `i` *in the range* `0 <= i < n`*, the digit* `i` *occurs* `num[i]` *times in* `num`*, otherwise return* `false`.

**Example 1:**

```
Input: num = "1210"
Output: true
Explanation:
num[0] = '1'. The digit 0 occurs once in num.
num[1] = '2'. The digit 1 occurs twice in num.
num[2] = '1'. The digit 2 occurs once in num.
num[3] = '0'. The digit 3 occurs zero times in num.
The condition holds true for every index in "1210", so return true.
```

**Example 2:**

```
Input: num = "030"
Output: false
Explanation:
num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = '0'. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false. 
```

**Constraints:**

-   `n == num.length`
-   `1 <= n <= 10`
-   `num` consists of digits.

### My Solution

*   Brute force method, the time complexity is $O(n^2)$, the space complexity is $O(n)$
*   **Important**: The character itself represents the number
    *   **Do not use** `Integer.valueOf` or `Integer.parseInt`: it only shows you the character number, not the integer it represents
    *   **Do use** `char - '0' ` or `Character.getNumericValue()` to transfer the character value to the numeric value

```java
public boolean digitCount(String num) {
    // brute force
    int n = num.length();
    int count = 0;
    char[] charArry = num.toCharArray();
    for (int i = 0; i < n; i++){
        count = 0;
        int expect = Character.getNumericValue(charArry[i]);
        for (int j = 0; j < n; j++){
            int current = Character.getNumericValue(charArry[j]);
            if (current == i){
                count++;
            }
        }
        if (count != expect){
            return false;
        }
    }
    return true;
}
```

### Standard Solution

#### Solution #1 Create a Digit Array

*   Use a 0-9 digit array to count the number of occurence

```java
public boolean digitCount(String num){
    int[] freq = new int[10]; // 0 - 9
    for (char c : num.toCharArray()){
        freq[c - '0']++; // count the occurence
    }
    for (int i = 0; i < num.length(); i++){
        if (num.charAt(i) - '0' != freq[i]) return false; // compare with the digit map
    }
    return true;
}
```

*   the time complexity is $O(n)$, the space complexity is $O(n)$

## Sender with Largest Word Count (Medium #2284)

**Question**: You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a **message** sent by `senders[i]`.

A **message** is list of **words** that are separated by a single space with no leading or trailing spaces. The **word count** of a sender is the total number of **words** sent by the sender. Note that a sender may send more than one message.

Return *the sender with the **largest** word count*. If there is more than one sender with the largest word count, return *the one with the **lexicographically largest** name*.

**Note:**

-   Uppercase letters come before lowercase letters in lexicographical order.
-   `"Alice"` and `"alice"` are distinct.

**Example 1:**

```
Input: messages = ["Hello userTwooo","Hi userThree","Wonderful day Alice","Nice day userThree"], senders = ["Alice","userTwo","userThree","Alice"]
Output: "Alice"
Explanation: Alice sends a total of 2 + 3 = 5 words.
userTwo sends a total of 2 words.
userThree sends a total of 3 words.
Since Alice has the largest word count, we return "Alice".
```

**Example 2:**

```
Input: messages = ["How is leetcode for everyone","Leetcode is useful for practice"], senders = ["Bob","Charlie"]
Output: "Charlie"
Explanation: Bob sends a total of 5 words.
Charlie sends a total of 5 words.
Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.
```

**Constraints:**

-   `n == messages.length == senders.length`
-   `1 <= n <= 104`
-   `1 <= messages[i].length <= 100`
-   `1 <= senders[i].length <= 10`
-   `messages[i]` consists of uppercase and lowercase English letters and `' '`.
-   All the words in `messages[i]` are separated by **a single space**.
-   `messages[i]` does not have leading or trailing spaces.
-   `senders[i]` consists of uppercase and lowercase English letters only.

### My Solution

*   Use hash map to store the sender with message word count
*   Each time trim the message and split with space, put into the map
*   Loop through the map to find the max sender
*   Time complexity: $O(n * m)$, $n$ is the number of messages, and $m$ is the word number of each message
*   Space complexity: $O(n)$, we use a hashmap to store the senders and word count

```java
public String largestWordCount(String[] messages, String[] senders) {
    // create a hash map to match the senders and word count
    Map<String, Integer> countMap = new HashMap<>();
    // both messages and senders should has same length
    int n = messages.length;
    for (int i = 0; i < n; i++){
        String sender = senders[i];
        String message = messages[i];
        // clean the messages and count its length
        String[] messageArry = message.split("\\s+");
        int stringCount = 0;
        for (String msg : messageArry){
            msg.trim();
            if (!msg.equals(" ")){
                stringCount++;
            }
        }
        if (countMap.containsKey(sender)){
            countMap.put(sender, countMap.get(sender) + stringCount);
        }
        else {
            countMap.put(sender, stringCount);
        }
    }
    int maxLength = 0;
    int preMax = 0;
    String maxSender = "";
    // loop through the map to find max sender
    for (Map.Entry<String, Integer> entry : countMap.entrySet()){
        //maxLength = Math.max(maxLength, entry.getValue());
        if (entry.getValue() > maxLength){
            maxSender = entry.getKey();
            maxLength = entry.getValue();
        }
        else if (entry.getValue() == maxLength){
            if (entry.getKey().compareTo(maxSender) > 0){
                maxSender = entry.getKey();
            }
        }
    }
    return maxSender;
}
```

### Standard Solution

#### Solution #1 Using HashMap

*   Same idea as my solution, but shorter and more efficient

```java
public String largestWordCount(String[] messages, String[] senders) {
    HashMap<String,Integer> hm=new HashMap<>();
    int max=0;
    String name="";
    for(int i=0;i<messages.length;i++){
        String[] words=messages[i].split(" ");
        int freq=hm.getOrDefault(senders[i],0)+words.length;
        hm.put(senders[i],freq);
        if(hm.get(senders[i])>max){ // keep compare to the max number
            max=hm.get(senders[i]);
            name=senders[i];
        }
        else if(hm.get(senders[i])==max && name.compareTo(senders[i])<0){ // compare the string
            name=senders[i];
        } 
    }
    return name;
}
```

*   Time and space complexity is the same as my solution

## Merge Intervals (Medium #56)

**Question**: Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 104`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 104`

### My Solution

```java
/**
* abstract: return non-overlapping intervals
* 1. sort the intervals by the start
* 2. merge the intervals by end-start
*/
public int[][] merge(int[][] intervals) {
    // sort the intervals
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    List<int[]> intervalList = new LinkedList<>();

    int min = intervals[0][0];
    int max = intervals[0][1];
    // merge the intervals by end-start
    for (int i = 1; i < intervals.length; i++){
        // current interval
        int start = intervals[i][0];
        int end = intervals[i][1];

        // compare with previous start and end
        if (max >= start){
            max = Math.max(max, end);
        }
        else {
            intervalList.add(new int[]{min, max});
            min = start;
            max = end;
        }
    }
    intervalList.add(new int[]{min, max});
    // create the final result int array
    int[][] res = new int[intervalList.size()][2];
    for (int i = 0; i < intervalList.size(); i++){
        res[i] = intervalList.get(i);
    }
    return res;
}
```

### Standard Solution

#### Solution #1 Sorting

*   Sort the 2D array with customized sorter

```java
public int[][] merge(int[][] intervals){
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    LinkedList<int[]> merged = new LinkedList<>();
    for (int[] interval : intervals){
        // if the list of merged intervals is empty of if the current
        // interval does not overlap with the previous, simply append it
        if (merged.isEmpty() || merged.getLast()[1] < interval[0]){
            merged.add(interval);
        }
        // otherwise, there is overlap, so we merge the current and previous intervals
        else {
            merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);
        }
    }
    return merged.toArray(new int[merged.size()]);
}
```

-   Time complexity: $O(n\log{}n)$. Other than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the $O(n\log{}n)$ complexity of sorting.

-   Space complexity: $O(\log N)$ (or $O(n)$)

    If we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes $O(\log n)$ space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that.

## Meeting Rooms (Easy #252)

**Question**: Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.

**Example 1:**

```
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
```

**Example 2:**

```
Input: intervals = [[7,10],[2,4]]
Output: true
```

**Constraints:**

-   `0 <= intervals.length <= 104`
-   `intervals[i].length == 2`
-   `0 <= starti < endi <= 106`

### My Solution

```java
public boolean canAttendMeetings(int[][] intervals) {
    // sort the intervals by the starting time of meetings
    // each time check the end time vs. next starting time of meeting

    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    int prev = 0;

    for (int[] interval : intervals){
        int start = interval[0];
        int end = interval[1];
        if (start < prev) return false;
        prev = end;
    }
    return true;
}
```

-   Time complexity: $O(n \log n)$. The time complexity is dominated by sorting. Once the array has been sorted, only $O(n)$ time is taken to go through the array and determine if there is any overlap.
-   Space complexity: $O(1)$. Since no additional space is allocated.