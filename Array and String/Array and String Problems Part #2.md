# Array and String Problems Part #2

## Permutation in String(Medium #567)

**Question**: Given two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

**Example 1:**

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

**Constraints:**

-   `1 <= s1.length, s2.length <= 104`
-   `s1` and `s2` consist of lowercase English letters.

### My Solution

*   Use a hashset to store the permutations, and use a slicing window to find if substring is contained by the hash set.
*   For the permutations, we can use backtracking to find all the permutations.
*   The method works, but it run over time limit since when the word is long, the runtime would be extremely slow.
*   Noted that actually we only need to return true or false, not the exact permutation, so we actually don't need to do backtracking.

```java
public boolean checkInclusion(String s1, String s2) {
    // s1 is the word, s2 is the string to find permutation word
    // build a arraylist to store the string since string is immutable
    if (s1.length() > s2.length()) return false;
    String[] wordString = s1.split("");
    int wordLength = s1.length();
    List<String> word = new ArrayList<>(Arrays.asList(wordString));
    Set<String> comb = new HashSet<>();
    permutation(0, comb, word);
    return check(comb, s2, wordLength);
}

public boolean check(Set<String> combination, String range, int wordLength){
    int rangeLength = range.length();
    String target;
    for (int i = 0; i < rangeLength - wordLength; i++){
        target = range.substring(i, i + wordLength);
        if (combination.contains(target)){
            return true;
        }
    }
    // the very end last possible permutation
    if (combination.contains(range.substring(rangeLength - wordLength))){
        return true;
    }
    return false;
}

public void permutation(int loc, Set<String> combination, List<String> word){
    if (loc == word.size()){
        StringBuilder wordString = new StringBuilder();
        for(String letter : word){
            wordString.append(letter);
        }
        combination.add(wordString.toString());
    }
    // loop through the word and store any combination to the set
    for (int begin = loc; begin < word.size(); begin++){
        Collections.swap(word, begin, loc);
        permutation(loc + 1, combination, word);
        Collections.swap(word, begin, loc);
    }
}
```

### Standard Solution

#### Solution #1 Slicing Window

```java
public boolean checkInclusion(String s1, String s2){
   if (s1.length() > s2.length()) return false;
   // we only need to check if they have same number letters in the string
   int[] s1map = new int[26];
   int[] s2map = new int[26];
   for (int i = 0; i < s1.length(); i++){
       s1map[s1.charAt(i) - 'a']++;
       s2map[s2.charAt(i) - 'a']++;
   }
   // each time modify the s2map to the current slicing window
   for (int i = 0; i < s2.length() - s1.length(); i++){
       if (matches(s1map, s2map)) return true;// if current slicing window met
       // move to the next window, step is 1
       s2map[s2.charAt(i + s1.length()) - 'a']++;
       s2map[s2.charAt(i) - 'a']--;
   }
   return matches(s1map, s2map);
}

public boolean matches(int[] s1map, int[] s2map){
    for (int i = 0; i < 26; i++){
        if (s1map[i] != s2map[i]){
            return false;
        }
    }
    return true;
}
```

*   Time complexity: $O(l_1+26*(l_2-l_1))$, where $l_1$ is the length of string $l_1$ and $l_2$ is the length of string $l_2$.
*   Space complexity: $O(1)$. Constant space is used.

## Find the Difference(Easy #389)

**Question**: You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`.

**Example 1:**

```
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```

**Example 2:**

```
Input: s = "", t = "y"
Output: "y"
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `t.length == s.length + 1`
-   `s` and `t` consist of lowercase English letters.

### My Solution

```java
public char findTheDifference(String s, String t) {
    int[] stringMap1 = new int[26];
    int[] stringMap2 = new int[26];
    char[] sArry = s.toCharArray();
    char[] tArry = t.toCharArray();
    int findLoc;
    // record the char in string and map to the int array
    for (int i = 0; i < sArry.length; i++){
        findLoc = sArry[i] - 'a';
        stringMap1[findLoc]++;
    }
    for (int i = 0; i < tArry.length; i++){
        findLoc = tArry[i] - 'a';
        stringMap2[findLoc]++;
    }
    char target = 'a';
    // compare two array to see which location is different and output
    for (int i = 0; i < stringMap1.length; i++){
        if (stringMap1[i] != stringMap2[i]){
            target = (char)('a' + i);
            break;
        }
    }
    return target;
}
```

### Standard Solution

#### Solution #1 Using HashMap

*   Use hashmap to store the string letter and its occurrence.
*   Then loop through another string and subtract the occurrence in hashmap until reaches 0.
*   Any new letter that is beyond the hashmap occurrence is the target.

```java
public char findTheDifference(String s, String t){
    char extraChar = '\0'; // just random initialization
    
    // prepare a counter for string s.
    // this hashmap holds the characters as keys and respective frequency as value
    HashMap<Character, Integer> counterS = new HashMap<>();
    for (int i = 0; i < s.length(); i++){
        char ch = s.charAt(i);
        counterS.put(ch, counterS.getOrDefault(ch, 0) + 1);
    }
    // Iterate through string t and find the character which is not in s.
    for (int i = 0; i < t.length(); i++){
        char ch = t.charAt(i);
        int countOfChar = counterS.getOrDefault(ch, 0);
        if (countOfChar == 0){
            extraChar = ch;
            break;
        } else {
            // once a match is found we reduce frequency left.
            // this eliminates the possibility of a false match later.
            counterS.put(ch, countOfChar - 1);
        }
    }
    return extraChar;
}
```

*   Time Complexity: $O(N)$, where N is length of the strings. Since, we iterate through both the strings once.
*   Space Complexity: $O(1)$. The problem states string `s` and string `t` have lowercase letters. Thus, the total number of unique characters and eventually buckets in the hash map possible are just 26.